cmake_minimum_required(VERSION 3.20)
project(DesktopTerminal-CEF)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 设置输出目录
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# 检测架构和平台
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(CEF_PLATFORM "windows64")
    set(CMAKE_ARCH "x64")
    message(STATUS "64位架构检测")
else()
    set(CEF_PLATFORM "windows32")
    set(CMAKE_ARCH "Win32")
    message(STATUS "32位架构检测")
endif()

# 全平台统一使用CEF 75以获得最大兼容性
set(CEF_VERSION "75.1.14+gc81164e+chromium-75.0.3770.100")
message(STATUS "使用CEF 75.1.14版本 - 全平台最大兼容性模式")

# 为所有平台设置CEF 75兼容性优化
if(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 4)
    message(STATUS "Windows 32位 - CEF 75原生支持")
else()
    message(STATUS "其他平台 - CEF 75统一兼容性模式")
endif()

# Windows平台特殊设置
if(WIN32)
    # 设置Windows应用程序属性（不显示控制台窗口）
    set(CMAKE_WIN32_EXECUTABLE TRUE)
    # 确保使用UTF-8编码
    add_compile_options("/utf-8")
    # 32位系统内存优化
    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        add_compile_definitions(CEF_32BIT_BUILD)
    endif()
endif()

# 添加cmake模块路径
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

# 包含CEF部署模块
include(DeployCEF)

# 查找Qt5
find_package(Qt5 COMPONENTS Core Widgets REQUIRED)

# 设置Qt5的MOC、UIC、RCC
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# 查找CEF - 启用详细调试
message(STATUS "=== CEF查找过程开始 ===")
message(STATUS "项目根目录: ${CMAKE_CURRENT_SOURCE_DIR}")
message(STATUS "构建目录: ${CMAKE_CURRENT_BINARY_DIR}")
message(STATUS "CMAKE模块路径: ${CMAKE_MODULE_PATH}")

# 检查third_party/cef目录
set(CEF_CHECK_DIR "${CMAKE_CURRENT_SOURCE_DIR}/third_party/cef")
if(EXISTS "${CEF_CHECK_DIR}")
    message(STATUS "✓ third_party/cef目录存在")
    file(GLOB CEF_SUBDIRS "${CEF_CHECK_DIR}/*")
    foreach(subdir ${CEF_SUBDIRS})
        if(IS_DIRECTORY "${subdir}")
            get_filename_component(dirname "${subdir}" NAME)
            message(STATUS "  发现子目录: ${dirname}")
        endif()
    endforeach()
else()
    message(WARNING "✗ third_party/cef目录不存在！")
endif()

find_package(CEF REQUIRED)

# 如果CEF wrapper库不存在但有源码，则编译wrapper库
message(STATUS "=== CEF Wrapper库编译检查 ===")
message(STATUS "CEF_FOUND: ${CEF_FOUND}")
message(STATUS "CEF_WRAPPER_SOURCE_DIR: ${CEF_WRAPPER_SOURCE_DIR}")
message(STATUS "CEF_WRAPPER_LIBRARY: ${CEF_WRAPPER_LIBRARY}")

if(CEF_FOUND AND CEF_WRAPPER_SOURCE_DIR AND NOT CEF_WRAPPER_LIBRARY)
    message(STATUS "编译CEF Wrapper库从源码: ${CEF_WRAPPER_SOURCE_DIR}")
elseif(CEF_FOUND AND NOT CEF_WRAPPER_SOURCE_DIR)
    # 尝试手动查找wrapper源码目录
    set(POSSIBLE_WRAPPER_DIRS
        "${CEF_ROOT_DIR}/libcef_dll"
        "${CEF_ROOT_DIR}/${CEF_BINARY_NAME}/libcef_dll"
    )
    
    foreach(wrapper_dir ${POSSIBLE_WRAPPER_DIRS})
        if(EXISTS "${wrapper_dir}" AND NOT CEF_WRAPPER_SOURCE_DIR)
            set(CEF_WRAPPER_SOURCE_DIR "${wrapper_dir}")
            message(STATUS "手动找到CEF Wrapper源码: ${CEF_WRAPPER_SOURCE_DIR}")
            break()
        endif()
    endforeach()
endif()

if(CEF_FOUND AND CEF_WRAPPER_SOURCE_DIR AND NOT CEF_WRAPPER_LIBRARY)
    message(STATUS "开始编译CEF Wrapper库: ${CEF_WRAPPER_SOURCE_DIR}")
    
    # 收集wrapper库源文件
    file(GLOB_RECURSE CEF_WRAPPER_SOURCES
        "${CEF_WRAPPER_SOURCE_DIR}/*.cc"
        "${CEF_WRAPPER_SOURCE_DIR}/*.cpp"
    )
    
    if(CEF_WRAPPER_SOURCES)
        # 创建wrapper静态库
        add_library(cef_dll_wrapper STATIC ${CEF_WRAPPER_SOURCES})
        
        # 设置wrapper库的include目录
        target_include_directories(cef_dll_wrapper PRIVATE
            ${CEF_INCLUDE_PATH}
            ${CEF_INCLUDE_PATH}/include
        )
        
        # 设置编译定义 - CEF wrapper需要的所有定义
        target_compile_definitions(cef_dll_wrapper PRIVATE
            -DUSING_CEF_SHARED
            -DNOMINMAX
            -DWIN32_LEAN_AND_MEAN
            -D_CRT_SECURE_NO_WARNINGS
            -D_SCL_SECURE_NO_WARNINGS
            -DWRAPPING_CEF_SHARED
        )
        
        # 平台特定设置
        if(WIN32)
            target_compile_definitions(cef_dll_wrapper PRIVATE
                -DWIN32
                -D_WINDOWS
                -DUNICODE
                -D_UNICODE
            )
            
            # 32位系统特殊处理
            if(CMAKE_SIZEOF_VOID_P EQUAL 4)
                target_compile_definitions(cef_dll_wrapper PRIVATE
                    -DCEF_32BIT_BUILD
                )
            endif()
        elseif(APPLE)
            target_compile_definitions(cef_dll_wrapper PRIVATE
                -DMACOSX
            )
        elseif(UNIX)
            target_compile_definitions(cef_dll_wrapper PRIVATE
                -DLINUX
            )
        endif()
        
        # 将编译的wrapper库添加到CEF_LIBRARIES
        list(APPEND CEF_LIBRARIES cef_dll_wrapper)
        
        message(STATUS "CEF Wrapper库编译配置完成")
    else()
        message(WARNING "CEF Wrapper源码目录为空: ${CEF_WRAPPER_SOURCE_DIR}")
    endif()
endif()

# 包含目录
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_SOURCE_DIR}/src
    ${CEF_INCLUDE_PATH}
)

# 源文件列表
set(SOURCES
    src/main.cpp
    src/core/application.cpp
    src/core/cef_manager.cpp
    src/core/secure_browser.cpp
    src/core/window_manager.cpp
    src/cef/cef_client_impl.cpp
    src/cef/cef_app_impl.cpp
    src/config/config_manager.cpp
    src/logging/logger.cpp
    src/security/security_controller.cpp
    src/security/keyboard_filter.cpp
)

# 头文件列表
set(HEADERS
    src/core/application.h
    src/core/cef_manager.h
    src/core/secure_browser.h
    src/core/window_manager.h
    src/cef/cef_client_impl.h
    src/cef/cef_app_impl.h
    src/config/config_manager.h
    src/logging/logger.h
    src/security/security_controller.h
    src/security/keyboard_filter.h
)

# QHotkey子项目
add_subdirectory(third_party/QHotkey)

# 创建可执行文件
add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})

# 验证CEF库并配置链接
message(STATUS "=== CEF库链接配置 ===")
message(STATUS "CEF_LIBRARIES: ${CEF_LIBRARIES}")

# 详细验证CEF库状态
message(STATUS "=== CEF库状态详细检查 ===")
message(STATUS "CEF_FOUND: ${CEF_FOUND}")
message(STATUS "CEF_LIBRARIES: ${CEF_LIBRARIES}")
message(STATUS "CEF_LIBRARY: ${CEF_LIBRARY}")
message(STATUS "CEF_WRAPPER_LIBRARY: ${CEF_WRAPPER_LIBRARY}")
message(STATUS "CEF_ROOT_DIR: ${CEF_ROOT_DIR}")

# 紧急修复：如果CEF库问题严重，提供临时绕过
if(NOT CEF_LIBRARIES AND DEFINED ENV{GITHUB_ACTIONS})
    message(WARNING "=== CEF库缺失紧急处理 ===")
    message(WARNING "在CI环境中检测到CEF库完全缺失")
    message(WARNING "这通常意味着CEF下载或解压失败")
    
    # 尝试手动查找任何可能的CEF库文件
    file(GLOB_RECURSE EMERGENCY_CEF_LIBS 
        "${CMAKE_CURRENT_SOURCE_DIR}/third_party/cef/**/*.lib"
    )
    
    if(EMERGENCY_CEF_LIBS)
        message(WARNING "找到紧急CEF库文件:")
        foreach(emergency_lib ${EMERGENCY_CEF_LIBS})
            message(WARNING "  - ${emergency_lib}")
            # 添加任何找到的.lib文件
            list(APPEND CEF_LIBRARIES "${emergency_lib}")
        endforeach()
    else()
        message(FATAL_ERROR "
        ❌ 严重错误：CEF库完全缺失！
        
        这表明CEF下载过程存在根本性问题。
        请检查上面的CEF下载日志以确定失败原因。
        
        可能的原因：
        1. 网络连接问题导致下载失败
        2. CEF包URL错误或不可访问
        3. 解压过程失败
        4. 权限问题
        
        建议的解决方案：
        1. 检查CEF下载日志
        2. 验证CEF版本URL的有效性
        3. 检查GitHub Actions的网络连接
        ")
    endif()
endif()

# 正常情况下确保CEF库存在
if(NOT CEF_LIBRARIES)
    message(FATAL_ERROR "CEF_LIBRARIES为空！CEF库未找到。请检查CEF安装。")
endif()

# 链接库配置 - 优化CEF链接顺序解决LNK2019错误
message(STATUS "=== 配置库链接 ===")

# 首先链接Qt5库
target_link_libraries(${PROJECT_NAME}
    Qt5::Core
    Qt5::Widgets
    qhotkey
)

# CEF库链接 - 关键的链接顺序修复
if(CEF_FOUND AND CEF_LIBRARIES)
    message(STATUS "链接CEF库列表: ${CEF_LIBRARIES}")
    
    # Windows特殊处理：确保正确的链接顺序
    if(WIN32)
        # 分离CEF主库和wrapper库
        set(CEF_MAIN_LIBS)
        set(CEF_WRAPPER_LIBS)
        
        foreach(cef_lib ${CEF_LIBRARIES})
            get_filename_component(lib_name "${cef_lib}" NAME_WE)
            if(lib_name MATCHES "^(lib)?cef$")
                list(APPEND CEF_MAIN_LIBS "${cef_lib}")
                message(STATUS "✓ CEF主库: ${cef_lib}")
            elseif(lib_name MATCHES "wrapper")
                list(APPEND CEF_WRAPPER_LIBS "${cef_lib}")
                message(STATUS "✓ CEF Wrapper库: ${cef_lib}")
            else()
                list(APPEND CEF_MAIN_LIBS "${cef_lib}")
                message(STATUS "✓ 其他CEF库: ${cef_lib}")
            endif()
        endforeach()
        
        # 正确的链接顺序：先链接主库，再链接wrapper库
        foreach(main_lib ${CEF_MAIN_LIBS})
            if(EXISTS "${main_lib}")
                target_link_libraries(${PROJECT_NAME} "${main_lib}")
                message(STATUS "✅ 已链接CEF主库: ${main_lib}")
            else()
                message(WARNING "⚠️ CEF主库文件不存在: ${main_lib}")
            endif()
        endforeach()
        
        foreach(wrapper_lib ${CEF_WRAPPER_LIBS})
            if(EXISTS "${wrapper_lib}")
                target_link_libraries(${PROJECT_NAME} "${wrapper_lib}")
                message(STATUS "✅ 已链接CEF Wrapper库: ${wrapper_lib}")
            else()
                message(STATUS "ℹ️ CEF Wrapper库不存在（将从源码编译）: ${wrapper_lib}")
            endif()
        endforeach()
    else()
        # 非Windows平台的标准链接
        foreach(cef_lib ${CEF_LIBRARIES})
            if(EXISTS "${cef_lib}")
                target_link_libraries(${PROJECT_NAME} "${cef_lib}")
                message(STATUS "✅ 已链接CEF库: ${cef_lib}")
            else()
                message(WARNING "⚠️ CEF库文件不存在: ${cef_lib}")
            endif()
        endforeach()
    endif()
else()
    message(WARNING "⚠️ CEF库列表为空，尝试手动查找和链接...")
    
    # 紧急修复：手动查找和链接CEF库
    if(WIN32 AND CEF_ROOT_DIR)
        set(EMERGENCY_CEF_PATHS
            "${CEF_ROOT_DIR}/${CEF_BINARY_NAME}/Release/libcef.lib"
            "${CEF_ROOT_DIR}/Release/libcef.lib"
            "${CEF_ROOT_DIR}/${CEF_BINARY_NAME}/Debug/libcef.lib"
            "${CEF_ROOT_DIR}/Debug/libcef.lib"
        )
        
        set(FOUND_EMERGENCY_LIB FALSE)
        foreach(emergency_path ${EMERGENCY_CEF_PATHS})
            if(EXISTS "${emergency_path}" AND NOT FOUND_EMERGENCY_LIB)
                target_link_libraries(${PROJECT_NAME} "${emergency_path}")
                message(STATUS "🆘 紧急链接CEF库: ${emergency_path}")
                set(FOUND_EMERGENCY_LIB TRUE)
            endif()
        endforeach()
        
        if(NOT FOUND_EMERGENCY_LIB)
            message(FATAL_ERROR "
❌ 严重错误：无法找到任何可链接的CEF库文件！

这将导致链接时出现LNK2019错误。

🔍 搜索路径:
${EMERGENCY_CEF_PATHS}

📋 解决方案：
1. 确保CEF已正确下载和解压
2. 检查CEF目录结构是否完整
3. 重新运行CEF下载脚本
4. 联系技术支持获取帮助
            ")
        endif()
    endif()
endif()

# CEF库特殊处理
if(CEF_FOUND)
    # 确保CEF include路径被正确设置
    target_include_directories(${PROJECT_NAME} PRIVATE
        ${CEF_INCLUDE_PATH}
        ${CEF_INCLUDE_PATH}/include
    )
    
    # macOS Framework特殊处理
    if(APPLE AND CEF_FRAMEWORK_PATH)
        message(STATUS "链接CEF Framework: ${CEF_FRAMEWORK_PATH}")
        target_link_libraries(${PROJECT_NAME} "-framework Cocoa")
        target_link_libraries(${PROJECT_NAME} "-framework ApplicationServices")
    endif()
endif()

# Windows特定链接库 - CEF需要的所有系统库
if(WIN32)
    target_link_libraries(${PROJECT_NAME}
        # 基础系统库
        comctl32.lib
        rpcrt4.lib
        shlwapi.lib
        ws2_32.lib
        
        # CEF特定的Windows库
        advapi32.lib
        dbghelp.lib
        dnsapi.lib
        gdi32.lib
        psapi.lib
        user32.lib
        version.lib
        winmm.lib
        winspool.lib
        ole32.lib
        oleaut32.lib
        uuid.lib
        shell32.lib
        kernel32.lib
    )
    
    # CEF特定的链接选项
    if(MSVC)
        target_link_options(${PROJECT_NAME} PRIVATE
            /SUBSYSTEM:WINDOWS
            /DELAYLOAD:libcef.dll
        )
    endif()
endif()

# 编译器特定设置
if(MSVC)
    # 禁用MSVC警告
    target_compile_definitions(${PROJECT_NAME} PRIVATE
        _CRT_SECURE_NO_WARNINGS
        NOMINMAX
        WIN32_LEAN_AND_MEAN
    )
    
    # 32位系统优化
    if(CMAKE_SIZEOF_VOID_P EQUAL 4)
        target_compile_options(${PROJECT_NAME} PRIVATE /bigobj)
    endif()
endif()

# 设置目标属性
set_target_properties(${PROJECT_NAME} PROPERTIES
    OUTPUT_NAME "DesktopTerminal-CEF"
    DEBUG_POSTFIX "_d"
)

# 部署CEF文件
if(CEF_FOUND)
    # 确保有CEF_ROOT变量用于部署
    if(NOT CEF_ROOT)
        set(CEF_ROOT "${CEF_ROOT_DIR}")
    endif()
    
    # 检查DeployCEF模块是否存在
    if(COMMAND deploy_cef_files)
        deploy_cef_files(${PROJECT_NAME}
            CEF_ROOT "${CEF_ROOT}"
            BINARY_DIR "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}"
            RESOURCES_DIR "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}"
        )
        
        # 配置CEF运行环境
        if(COMMAND configure_cef_environment)
            configure_cef_environment(${PROJECT_NAME})
        endif()
        
        # 验证CEF部署
        if(COMMAND verify_cef_deployment)
            verify_cef_deployment(${PROJECT_NAME} "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}")
        endif()
    else()
        message(STATUS "DeployCEF模块不可用，跳过CEF文件部署")
        message(STATUS "请确保CEF二进制文件和资源在运行时可用")
        message(STATUS "CEF根目录: ${CEF_ROOT}")
        message(STATUS "CEF二进制目录: ${CEF_BINARY_DIR}")
        message(STATUS "CEF资源目录: ${CEF_RESOURCE_DIR}")
    endif()
endif()

# 安装配置
install(TARGETS ${PROJECT_NAME}
    DESTINATION bin
)

# CEF资源文件安装
if(CEF_FOUND)
    install(DIRECTORY ${CEF_RESOURCE_DIR}/
        DESTINATION bin
        FILES_MATCHING 
        PATTERN "*.pak"
        PATTERN "*.dat"
        PATTERN "*.bin"
    )
    
    install(DIRECTORY ${CEF_BINARY_DIR}/
        DESTINATION bin
        FILES_MATCHING 
        PATTERN "*.dll"
        PATTERN "*.exe"
        PATTERN "*.so"
        PATTERN "*.dylib"
    )
endif()