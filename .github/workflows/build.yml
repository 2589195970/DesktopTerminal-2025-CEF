name: Build DesktopTerminal-CEF

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  release:
    types: [published]
  workflow_dispatch:  # 允许手动触发

env:
  BUILD_TYPE: Release
  QT_VERSION: '5.15.2'

jobs:
  # Windows构建（支持32位和64位）
  build-windows:
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x86
            platform: Win32
            cef_version: "75.1.14+gc81164e+chromium-75.0.3770.100"
            qt_arch: win32_msvc2019
            name: "Windows 32-bit (CEF 75 - Maximum Compatibility)"
          - arch: x64
            platform: x64
            cef_version: "75.1.14+gc81164e+chromium-75.0.3770.100"
            qt_arch: win64_msvc2019_64
            name: "Windows 64-bit (CEF 75 - Maximum Compatibility)"

    name: ${{ matrix.name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup MSVC Environment
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: ${{ matrix.arch }}

    - name: Check Available Qt Architectures
      shell: cmd
      run: |
        echo "检查Qt ${{ env.QT_VERSION }}可用架构..."
        python -m pip install aqtinstall==3.1.*
        python -m aqt list-qt windows desktop --arch ${{ env.QT_VERSION }} || echo "架构检查失败，继续尝试安装"

    - name: Install Qt ${{ env.QT_VERSION }}
      uses: jurplel/install-qt-action@v3
      timeout-minutes: 15
      with:
        version: ${{ env.QT_VERSION }}
        arch: ${{ matrix.qt_arch }}
        cache: true
        cache-key-prefix: qt-5.15.2-${{ matrix.arch }}

    - name: Cache CEF ${{ matrix.arch }}
      id: cache-cef
      uses: actions/cache@v4
      with:
        path: third_party/cef
        key: cef-windows-${{ matrix.arch }}-75.1.14-stable-v7
        restore-keys: |
          cef-windows-${{ matrix.arch }}-75.1.14-stable-
          cef-windows-${{ matrix.arch }}-75.1.14-
          cef-windows-${{ matrix.arch }}-75-

    - name: Verify CEF Cache Status
      id: verify-cef-cache  
      shell: cmd
      # [INFO] 重要：验证CEF缓存完整性，避免不完整的CEF导致链接错误
      # 这个步骤经过多版本调试，请勿轻易删除或简化
      run: |
        setlocal enabledelayedexpansion
        echo "=== CEF缓存状态验证 ==="
        
        REM 根据架构确定CEF版本
        if "${{ matrix.arch }}"=="x86" (
          set "CEF_VERSION=${{ matrix.cef_version }}"
          set "CEF_PLATFORM=windows32"
        ) else (
          set "CEF_VERSION=${{ matrix.cef_version }}"
          set "CEF_PLATFORM=windows64"
        )
        
        echo "CEF配置信息:"
        echo "  架构: ${{ matrix.arch }}"
        echo "  CEF版本: !CEF_VERSION!"
        echo "  CEF平台: !CEF_PLATFORM!"
        echo "  缓存状态: ${{ steps.cache-cef.outputs.cache-hit }}"
        
        set "CEF_BINARY_NAME=cef_binary_!CEF_VERSION!_!CEF_PLATFORM!"
        echo "  预期CEF目录: !CEF_BINARY_NAME!"
        
        REM 验证缓存内容完整性
        set "CEF_VALID=false"
        if "${{ steps.cache-cef.outputs.cache-hit }}"=="true" (
          echo "检查缓存的CEF完整性..."
          if exist "third_party\cef\!CEF_BINARY_NAME!\include\cef_version.h" (
            if exist "third_party\cef\!CEF_BINARY_NAME!\Release\libcef.lib" (
              if exist "third_party\cef\!CEF_BINARY_NAME!\libcef_dll" (
                echo "[OK] CEF缓存验证通过 - 所有关键文件存在"
                set "CEF_VALID=true"
              ) else (
                echo "[ERROR] CEF Wrapper源码缺失"
              )
            ) else (
              echo "[ERROR] CEF主库文件缺失"
            )
          ) else (
            echo "[ERROR] CEF头文件缺失"
          )
        ) else (
          echo "未命中缓存，需要下载CEF"
        )
        
        if "!CEF_VALID!"=="false" (
          echo "清理不完整的CEF目录..."
          if exist "third_party\cef" (
            rmdir /s /q "third_party\cef" 2>nul
          )
        )
        
        echo "cef-valid=!CEF_VALID!" >> %GITHUB_OUTPUT%
        echo "CEF验证结果: !CEF_VALID!"

    - name: Download CEF
      if: steps.cache-cef.outputs.cache-hit != 'true' || steps.verify-cef-cache.outputs.cef-valid != 'true'
      shell: cmd
      run: |
        echo "下载CEF for ${{ matrix.arch }}..."
        echo "强制重新下载以确保库文件完整..."
        if exist "third_party\cef" (
          echo "删除现有CEF目录以确保全新安装..."
          rmdir /s /q "third_party\cef"
        )
        if "${{ matrix.arch }}"=="x86" (
          scripts\download-cef.bat "/platform=windows32" "/force"
        ) else (
          scripts\download-cef.bat "/platform=windows64" "/force"
        )
        
        echo "=== 详细验证下载结果 ==="
        if exist "third_party\cef" (
          echo "CEF根目录内容："
          dir "third_party\cef" /b
          
          echo "查找所有库文件："
          dir "third_party\cef" /s /b | findstr /i "\.lib$"
          
          echo "查找所有DLL文件："
          dir "third_party\cef" /s /b | findstr /i "\.dll$"
          
          echo "查找头文件："
          dir "third_party\cef" /s /b | findstr /i "cef_version\.h$"
          
          REM 特别检查预期的库文件
          for /d %%d in ("third_party\cef\cef_binary_*") do (
            echo "=== 检查 %%d ==="
            if exist "%%d\Release\libcef.lib" (
              echo "[OK] 找到主库: %%d\Release\libcef.lib"
              for %%f in ("%%d\Release\libcef.lib") do echo "  大小: %%~zf bytes"
            ) else (
              echo "[ERROR] 主库缺失: %%d\Release\libcef.lib"
            )
            
            if exist "%%d\libcef_dll" (
              echo "[OK] Wrapper源码存在: %%d\libcef_dll"
            ) else (
              echo "[ERROR] Wrapper源码缺失: %%d\libcef_dll"
            )
          )
        ) else (
          echo "[ERROR] CEF目录下载失败！"
        )

    - name: Final CEF Verification
      shell: cmd
      # [CHECK] 关键步骤：最终CEF完整性验证，包含多路径检查适配不同CEF版本
      # 支持多种CEF目录结构，经过实战验证的错误处理逻辑
      run: |
        echo "=== 详细CEF验证 ==="
        echo "检查CEF目录结构和关键文件..."
        
        if exist "third_party\cef" (
          echo "CEF根目录内容："
          dir "third_party\cef" /b
          
          REM 查找所有cef_binary目录
          for /d %%d in ("third_party\cef\cef_binary_*") do (
            echo "=== 检查 %%d ==="
            if exist "%%d\include\cef_version.h" (
              echo "[OK] 头文件存在: %%d\include\cef_version.h"
            ) else (
              echo "[ERROR] 头文件缺失: %%d\include\cef_version.h"
            )
            
            if exist "%%d\Release" (
              echo "[OK] Release目录存在，内容："
              dir "%%d\Release" /b | findstr /i "\.lib"
              if exist "%%d\Release\libcef.lib" (
                echo "[OK] 关键库文件存在: libcef.lib"
              ) else (
                echo "[ERROR] 关键库文件缺失: libcef.lib"
              )
            ) else (
              echo "[ERROR] Release目录缺失"
            )
            
            if exist "%%d\libcef_dll" (
              echo "[OK] CEF Wrapper源码目录存在"
              dir "%%d\libcef_dll" /b | findstr /i "\.h \.cc"
            ) else (
              echo "[ERROR] CEF Wrapper源码目录缺失"
            )
          )
        ) else (
          echo "[ERROR] CEF目录完全不存在！"
        )
        setlocal enabledelayedexpansion
        echo "最终CEF验证..."
        set "VERIFICATION_FAILED=false"
        
        REM 根据架构确定CEF版本和路径
        if "${{ matrix.arch }}"=="x86" (
          set "CEF_VERSION=${{ matrix.cef_version }}"
          set "CEF_PLATFORM=windows32"
        ) else (
          set "CEF_VERSION=${{ matrix.cef_version }}"
          set "CEF_PLATFORM=windows64"
        )
        
        set "CEF_BINARY_NAME=cef_binary_!CEF_VERSION!_!CEF_PLATFORM!"
        
        REM 支持多种CEF目录结构的验证
        echo "检查CEF目录结构的多种可能性..."
        
        REM 检查关键CEF头文件
        set "HEADER_FILES=cef_version.h cef_app.h cef_client.h"
        set "HEADERS_FOUND=0"
        
        for %%h in (!HEADER_FILES!) do (
          set "HEADER_FOUND=false"
          
          REM 多路径检查头文件
          set "HEADER_PATHS[1]=third_party\cef\!CEF_BINARY_NAME!\include\%%h"
          set "HEADER_PATHS[2]=third_party\cef\include\%%h"
          set "HEADER_PATHS[3]=third_party\cef\!CEF_BINARY_NAME!\%%h"
          
          for /l %%i in (1,1,3) do (
            if "!HEADER_FOUND!"=="false" (
              if exist "!HEADER_PATHS[%%i]!" (
                echo "[OK] 找到头文件: %%h at !HEADER_PATHS[%%i]!"
                set "HEADER_FOUND=true"
                set /a HEADERS_FOUND+=1
              )
            )
          )
          
          if "!HEADER_FOUND!"=="false" (
            echo "[ERROR] 缺失头文件: %%h"
            set "VERIFICATION_FAILED=true"
          )
        )
        
        REM 检查CEF库文件（更灵活的路径）
        set "LIB_FOUND=false"
        set "LIB_PATHS[1]=third_party\cef\!CEF_BINARY_NAME!\Release\libcef.lib"
        set "LIB_PATHS[2]=third_party\cef\Release\libcef.lib"
        set "LIB_PATHS[3]=third_party\cef\!CEF_BINARY_NAME!\lib\libcef.lib"
        
        for /l %%i in (1,1,3) do (
          if "!LIB_FOUND!"=="false" (
            if exist "!LIB_PATHS[%%i]!" (
              echo "[OK] 找到CEF库文件: !LIB_PATHS[%%i]!"
              set "LIB_FOUND=true"
            )
          )
        )
        
        if "!LIB_FOUND!"=="false" (
          echo "[ERROR] 缺失CEF库文件(libcef.lib)"
          set "VERIFICATION_FAILED=true"
        )
        
        REM 最终验证结果
        if "!VERIFICATION_FAILED!"=="true" (
          echo "[ERROR] CEF验证失败 - 部分关键文件缺失"
          echo "找到的头文件数量: !HEADERS_FOUND!/3"
          echo "CEF目录结构（用于诊断）:"
          if exist "third_party\cef" (
            echo "--- CEF头文件 ---"
            dir "third_party\cef" /s /b | findstr /i "\.h$" | findstr /i "cef"
            echo "--- CEF库文件 ---"  
            dir "third_party\cef" /s /b | findstr /i "\.lib$"
            echo "--- 目录结构 ---"
            tree "third_party\cef" /F || dir "third_party\cef" /s /b
          )
          exit /b 1
        ) else (
          echo "[SUCCESS] CEF验证成功 - 所有关键文件都存在"
          echo "[SUCCESS] 找到头文件: !HEADERS_FOUND!/3"
          echo "[SUCCESS] 找到库文件: libcef.lib"
          echo "CEF安装路径: third_party\cef\!CEF_BINARY_NAME!"
        )

    - name: Pre-Build Environment Diagnostics
      shell: cmd
      # [REPORT] 诊断信息收集：为构建失败时的问题排查提供关键信息
      # 每个诊断项都有实际调试价值，建议保留完整逻辑
      run: |
        echo "[INFO] === 构建环境诊断报告 ==="
        echo "[REPORT] 收集环境信息以协助问题诊断..."
        echo.
        
        echo "[SYSTEM]  --- 系统信息 ---"
        echo "操作系统: %OS%"
        echo "处理器架构: %PROCESSOR_ARCHITECTURE%"
        echo "处理器标识: %PROCESSOR_IDENTIFIER%"
        echo "构建架构: ${{ matrix.arch }}"
        echo "Qt架构: ${{ matrix.qt_arch }}"
        
        echo.
        echo "[TOOLS] --- Qt环境检查 ---"
        echo "Qt5_Dir: %Qt5_Dir%"
        if exist "%Qt5_Dir%" (
          echo "[OK] Qt5目录存在"
          echo "Qt5版本信息:"
          if exist "%Qt5_Dir%\bin\qmake.exe" (
            "%Qt5_Dir%\bin\qmake.exe" -query QT_VERSION 2>nul || echo "无法获取Qt版本"
          )
        ) else (
          echo "[ERROR] Qt5目录不存在"
        )
        
        echo.
        echo "[CHECK] --- CEF环境检查 ---"
        if exist "third_party\cef" (
          echo "[OK] CEF目录存在"
          echo "CEF目录大小和内容:"
          for /d %%d in ("third_party\cef\cef_binary_*") do (
            echo "  CEF目录: %%d"
            if exist "%%d\Release\libcef.lib" (
              for %%f in ("%%d\Release\libcef.lib") do echo "    libcef.lib: %%~zf bytes"
            ) else (
              echo "    [ERROR] libcef.lib缺失"
            )
            if exist "%%d\include\cef_version.h" (
              echo "    [OK] 头文件存在"
            ) else (
              echo "    [ERROR] 头文件缺失"
            )
          )
        ) else (
          echo "[ERROR] CEF目录不存在 - 这将导致构建失败"
        )
        
        echo.
        echo "[TOOLS]  --- 编译工具链检查 ---"
        echo "[INFO] Visual Studio版本:"
        where cl 2>nul && cl 2>&1 | findstr "Version" || echo "[ERROR] 无法找到cl编译器"
        echo "[INFO] CMake版本:"
        cmake --version 2>nul || echo "[ERROR] 无法找到cmake"
        echo "[INFO] MSBuild版本:"
        where msbuild 2>nul && msbuild -version 2>nul || echo "[ERROR] 无法找到msbuild"
        
        echo.
        echo "[DISK] --- 磁盘空间检查 ---"
        for %%d in (C: D:) do (
          if exist %%d\ (
            for /f "tokens=3" %%a in ('dir %%d\ /-c ^| find "bytes free"') do echo "%%d 可用空间: %%a bytes"
          )
        )
        
        echo.
        echo "[SUCCESS] === 诊断报告完成 ==="

    - name: Configure CMake
      shell: cmd
      run: |
        echo "=== CMake配置阶段 ==="
        echo "Qt5_Dir environment: %Qt5_Dir%"
        echo "当前工作目录: %CD%"
        echo "验证构建环境..."
        
        REM 检查关键依赖
        if not exist "%Qt5_Dir%" (
          echo "[ERROR] Qt5目录不存在: %Qt5_Dir%"
          exit /b 1
        )
        
        if not exist "third_party\cef" (
          echo "[ERROR] CEF目录不存在 - 这将导致CMake配置失败"
          exit /b 1
        )
        
        echo "[SUCCESS] 基础依赖检查通过"
        mkdir build 2>nul
        cd build
        
        echo "--- CMake配置开始 ---"
        REM Configure for Windows 7 SP1 compatibility
        if "${{ matrix.arch }}"=="x86" (
          echo "配置Windows 7 SP1 32位兼容性构建..."
          cmake .. ^
            -A ${{ matrix.platform }} ^
            -T v142 ^
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} ^
            -DCEF_VERSION="${{ matrix.cef_version }}" ^
            -DCMAKE_PREFIX_PATH="%Qt5_Dir%" ^
            -DQt5_DIR="%Qt5_Dir%/lib/cmake/Qt5" ^
            -DCMAKE_SYSTEM_VERSION=7.1 ^
            -DCMAKE_VERBOSE_MAKEFILE=ON
        ) else (
          echo "配置Windows 10+ 64位构建..."
          cmake .. ^
            -A ${{ matrix.platform }} ^
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} ^
            -DCEF_VERSION="${{ matrix.cef_version }}" ^
            -DCMAKE_PREFIX_PATH="%Qt5_Dir%" ^
            -DQt5_DIR="%Qt5_Dir%/lib/cmake/Qt5" ^
            -DCMAKE_VERBOSE_MAKEFILE=ON
        )
        
        if %errorlevel% neq 0 (
          echo "[ERROR] CMake配置失败"
          echo "错误级别: %errorlevel%"
          echo "--- CMake错误诊断 ---"
          echo "CMakeCache.txt内容（如果存在）:"
          if exist "CMakeCache.txt" (
            findstr /i "cef\|qt\|error" CMakeCache.txt || echo "未找到相关错误信息"
          ) else (
            echo "CMakeCache.txt不存在"
          )
          echo "CMakeFiles/CMakeError.log内容（如果存在）:"
          if exist "CMakeFiles\CMakeError.log" (
            type "CMakeFiles\CMakeError.log"
          ) else (
            echo "CMakeError.log不存在"
          )
          exit /b 1
        ) else (
          echo "[SUCCESS] CMake配置成功"
          
          REM 正确设置环境变量给后续步骤
          echo CMAKE_CONFIG_SUCCESS=true>>%GITHUB_ENV%
          echo CMAKE_BUILD_DIR=%CD%>>%GITHUB_ENV%
          
          echo "--- 环境变量设置验证 ---"
          echo "设置CMAKE_CONFIG_SUCCESS=true"
          echo "设置CMAKE_BUILD_DIR=%CD%"
          
          echo "--- 配置验证 ---"
          echo "解决方案文件:"
          dir *.sln /b || echo "未找到解决方案文件"
          echo "项目文件:"
          dir *.vcxproj /b || echo "未找到项目文件"
          echo "[TARGET] 准备执行构建步骤..."
        )

    - name: Build Project  
      shell: cmd
      run: |
        setlocal enabledelayedexpansion
        echo "=== 项目编译阶段 ==="
        
        echo "--- 环境变量读取验证 ---"
        echo "CMAKE_CONFIG_SUCCESS环境变量: '%CMAKE_CONFIG_SUCCESS%'"
        echo "CMAKE_BUILD_DIR环境变量: '%CMAKE_BUILD_DIR%'"
        
        REM 验证前置条件
        if not "%CMAKE_CONFIG_SUCCESS%"=="true" (
          echo "[ERROR] CMake配置未成功，无法继续构建"
          echo "CMAKE_CONFIG_SUCCESS='%CMAKE_CONFIG_SUCCESS%' (应该是'true')"
          echo "这表明环境变量传递失败或CMake配置步骤未成功"
          echo "请检查前一步骤的环境变量设置"
          exit /b 1
        ) else (
          echo "[SUCCESS] 环境变量验证通过：CMAKE_CONFIG_SUCCESS=true"
        )
        
        if not exist "%CMAKE_BUILD_DIR%" (
          echo "[ERROR] 构建目录不存在: %CMAKE_BUILD_DIR%"
          echo "尝试使用默认构建目录..."
          if exist "build" (
            echo "[OK] 找到默认构建目录"
            cd build
          ) else (
            echo "[ERROR] 无法找到任何构建目录"
            exit /b 1
          )
        ) else (
          echo "[OK] 使用配置的构建目录: %CMAKE_BUILD_DIR%"
          cd "%CMAKE_BUILD_DIR%"
        )
        
        echo "--- 编译前最后检查 ---"
        echo "当前工作目录: %CD%"
        echo "构建目录内容:"
        dir . /b
        
        echo "检查生成的项目文件:"
        if exist "*.sln" (
          for %%f in (*.sln) do echo "[OK] 解决方案文件: %%f"
        ) else (
          echo "[ERROR] 未找到解决方案文件"
          echo "[ERROR] 这表明CMake配置可能未完全成功"
          exit /b 1
        )
        
        if exist "*.vcxproj" (
          echo "[OK] 找到项目文件"
          echo "项目文件列表:"
          dir *.vcxproj /b
        ) else (
          echo "[ERROR] 未找到项目文件"
          echo "[ERROR] 这表明CMake配置可能未完全成功"
          exit /b 1
        )
        
        echo "--- 开始编译 ---"
        echo "编译配置: ${{ env.BUILD_TYPE }}"
        echo "并行数: %NUMBER_OF_PROCESSORS%"
        echo "目标平台: ${{ matrix.platform }}"
        
        echo "[BUILD] 执行构建命令..."
        echo "命令: cmake --build . --config ${{ env.BUILD_TYPE }} --parallel %NUMBER_OF_PROCESSORS% --verbose"
        
        REM 设置详细输出以便诊断链接错误
        cmake --build . --config ${{ env.BUILD_TYPE }} --parallel %NUMBER_OF_PROCESSORS% --verbose
        
        set "BUILD_RESULT=%errorlevel%"
        echo "构建命令完成，返回码: %BUILD_RESULT%"
        
        if !BUILD_RESULT! neq 0 (
          echo "[ERROR] 编译失败，错误级别: !BUILD_RESULT!"
          echo "--- 编译错误诊断 ---"
          
          REM 检查是否是链接错误（LNK2019等）
          if exist "*.log" (
            echo "检查构建日志中的链接错误..."
            for %%f in (*.log) do (
              findstr /i "LNK2019\|LNK1120\|unresolved external symbol" "%%f" && (
                echo "发现链接错误在: %%f"
                echo "--- 链接错误详情 ---"
                findstr /i "LNK\|unresolved\|external symbol" "%%f"
              )
            )
          )
          
          REM 检查构建输出目录
          echo "--- 构建输出检查 ---"
          if exist "bin" (
            echo "bin目录内容:"
            dir bin /s /b
          ) else (
            echo "bin目录不存在"
          )
          
          if exist "lib" (
            echo "lib目录内容:"
            dir lib /s /b
          ) else (
            echo "lib目录不存在"
          )
          
          REM 检查中间文件
          echo "--- 中间文件检查 ---"
          dir /s /b *.obj && echo "..." || echo "未找到目标文件"
          dir /s /b *.lib && echo "..." || echo "未找到库文件"
          
          echo "--- 错误总结 ---"
          echo "这很可能是CEF库链接问题导致的LNK2019错误"
          echo "请检查以上诊断信息，特别是链接错误详情"
          
          exit /b !BUILD_RESULT!
        ) else (
          echo "[SUCCESS] 编译成功！"
          echo "--- 编译结果验证 ---"
          
          REM 验证生成的可执行文件
          if exist "bin\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe" (
            echo "[SUCCESS] 主程序文件生成成功"
            for %%f in ("bin\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe") do (
              echo "  文件大小: %%~zf bytes"
            )
          ) else (
            echo "[WARNING] 主程序文件未找到，但编译报告成功"
            echo "检查bin目录结构:"
            if exist "bin" (
              dir bin /s /b
            ) else (
              echo "bin目录不存在"
            )
          )
          
          REM 验证生成的库文件
          if exist "lib\${{ env.BUILD_TYPE }}\*.lib" (
            echo "[SUCCESS] 库文件生成:"
            dir "lib\${{ env.BUILD_TYPE }}\*.lib" /b
          ) else (
            echo "[INFO] 未找到生成的库文件（可能正常）"
          )
          
          echo "[SUCCESS] Windows ${{ matrix.arch }}位构建完成！"
          
          REM 正确设置构建成功环境变量
          echo BUILD_SUCCESS=true>>%GITHUB_ENV%
          echo "--- 构建成功总结 ---"
          echo "[SUCCESS] 编译成功完成"
          echo "[SUCCESS] 可执行文件应已生成"
          echo "[SUCCESS] 库文件已编译"
          echo "[SUCCESS] 设置BUILD_SUCCESS=true"
          echo "[TARGET] 准备进行构建验证..."
        )

    - name: Verify Build and CEF Files
      shell: cmd
      run: |
        echo "=== 构建和CEF文件验证阶段 ==="
        echo "检查构建产物和CEF文件完整性..."
        
        REM 首先检查是否在正确的目录
        echo "当前工作目录: %CD%"
        
        REM 检查多个可能的位置 - 使用标准批处理语法
        set "FOUND_EXE=false"
        
        REM 检查第一个位置: build\bin\Release\DesktopTerminal-CEF.exe
        set "EXE_PATH1=build\bin\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe"
        if exist "%EXE_PATH1%" (
          echo "[FOUND] 找到可执行文件: %EXE_PATH1%"
          for %%f in ("%EXE_PATH1%") do echo "  文件大小: %%~zf bytes"
          set "FOUND_EXE=true"
          goto :found_exe
        ) else (
          echo "[NOT FOUND] 未找到: %EXE_PATH1%"
        )
        
        REM 检查第二个位置: build\bin\Release\DesktopTerminal-CEF.exe
        set "EXE_PATH2=build\bin\Release\DesktopTerminal-CEF.exe"
        if exist "%EXE_PATH2%" (
          echo "[FOUND] 找到可执行文件: %EXE_PATH2%"
          for %%f in ("%EXE_PATH2%") do echo "  文件大小: %%~zf bytes"
          set "FOUND_EXE=true"
          goto :found_exe
        ) else (
          echo "[NOT FOUND] 未找到: %EXE_PATH2%"
        )
        
        REM 检查第三个位置: build\Release\DesktopTerminal-CEF.exe
        set "EXE_PATH3=build\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe"
        if exist "%EXE_PATH3%" (
          echo "[FOUND] 找到可执行文件: %EXE_PATH3%"
          for %%f in ("%EXE_PATH3%") do echo "  文件大小: %%~zf bytes"
          set "FOUND_EXE=true"
          goto :found_exe
        ) else (
          echo "[NOT FOUND] 未找到: %EXE_PATH3%"
        )
        
        REM 检查第四个位置: bin\Release\DesktopTerminal-CEF.exe
        set "EXE_PATH4=bin\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe"
        if exist "%EXE_PATH4%" (
          echo "[FOUND] 找到可执行文件: %EXE_PATH4%"
          for %%f in ("%EXE_PATH4%") do echo "  文件大小: %%~zf bytes"
          set "FOUND_EXE=true"
          goto :found_exe
        ) else (
          echo "[NOT FOUND] 未找到: %EXE_PATH4%"
        )
        
        :found_exe
        if "%FOUND_EXE%"=="true" (
          echo "[OK] 主程序文件找到，开始CEF文件完整性检查..."
          
          REM 检查CEF关键文件是否存在
          set "CEF_FILES_OK=true"
          set "BUILD_DIR="
          
          REM 简化的构建目录确定（基于已找到的可执行文件）
          echo "[INFO] 根据可执行文件位置确定构建目录..."
          
          REM 既然找到了可执行文件，直接基于其位置设置BUILD_DIR
          if exist "build\bin\Release\DesktopTerminal-CEF.exe" (
            set "BUILD_DIR=build\bin\Release"
            echo "[INFO] 使用Release构建目录"
          ) else (
            if exist "build\Release\DesktopTerminal-CEF.exe" (
              set "BUILD_DIR=build\Release"
              echo "[INFO] 使用简化Release构建目录"
            ) else (
              if exist "build\bin\Debug\DesktopTerminal-CEF.exe" (
                set "BUILD_DIR=build\bin\Debug"
                echo "[INFO] 使用Debug构建目录"
              ) else (
                echo "[WARNING] 无法确定构建目录位置"
              )
            )
          )
          
          REM 验证BUILD_DIR是否正确设置
          if "%BUILD_DIR%"=="" (
            echo "[ERROR] 无法确定构建目录，终止CEF验证"
            echo "[INFO] 可用的构建目录结构："
            if exist "build" (
              dir "build" /b
              if exist "build\bin" (
                echo "build\bin目录内容："
                dir "build\bin" /b
              )
            )
            set "CEF_FILES_OK=false"
            goto :skip_cef_check
          ) else (
            echo "使用构建目录: %BUILD_DIR%"
          )
          
          REM 检查关键CEF文件
          set "CEF_CORE_FILES=libcef.dll cef.pak"
          for %%f in (%CEF_CORE_FILES%) do (
            if exist "%BUILD_DIR%\%%f" (
              echo "[OK] CEF核心文件存在: %%f"
              for %%s in ("%BUILD_DIR%\%%f") do echo "   大小: %%~zs bytes"
            ) else (
              echo "[ERROR] CEF核心文件缺失: %%f"
              set "CEF_FILES_OK=false"
            )
          )
          
          REM 检查locales目录
          if exist "%BUILD_DIR%\locales" (
            echo "[OK] CEF本地化文件存在"
            echo "   locales目录已验证"
          ) else (
            echo "[ERROR] CEF本地化文件缺失"
            set "CEF_FILES_OK=false"
          )
          
          REM 简化的文件存在性验证（避免复杂的数学运算）
          echo "[INFO] 验证关键文件存在性..."
          if defined BUILD_DIR (
            echo "[INFO] 检查主要文件..."
            
            REM 检查主程序文件
            if exist "%BUILD_DIR%\DesktopTerminal-CEF.exe" (
              for %%f in ("%BUILD_DIR%\DesktopTerminal-CEF.exe") do (
                echo "  [OK] 主程序: %%~zf bytes"
              )
            ) else (
              echo "  [ERROR] 主程序文件缺失"
              set "CEF_FILES_OK=false"
            )
            
            REM 检查CEF核心DLL
            if exist "%BUILD_DIR%\libcef.dll" (
              for %%f in ("%BUILD_DIR%\libcef.dll") do (
                echo "  [OK] CEF核心库: %%~zf bytes"
              )
            ) else (
              echo "  [WARNING] CEF核心库未找到（可能在构建后复制）"
            )
            
            echo "[INFO] 核心文件验证完成"
          ) else (
            echo "[WARNING] 构建目录未确定，跳过文件验证"
          )
          
          :skip_cef_check
          if "%CEF_FILES_OK%"=="true" (
            echo "[SUCCESS] 构建和CEF文件验证成功！"
            echo "[INFO] 验证摘要："
            echo "   - 主程序: OK"
            echo "   - CEF核心文件: OK"
            echo "   - 本地化文件: OK"
            echo "   - 文件验证: 已完成"
            echo BUILD_SUCCESS=true>>%GITHUB_ENV%
            echo "[OK] 设置BUILD_SUCCESS=true以供后续步骤使用"
          ) else (
            echo "[ERROR] CEF文件验证失败"
            echo "--- CEF文件诊断信息 ---"
            echo "构建目录: %BUILD_DIR%"
            echo "目录内容："
            dir "%BUILD_DIR%" /b
            echo "DLL文件："
            dir "%BUILD_DIR%\*.dll" /b 2>nul || echo "未找到DLL文件"
            echo "PAK文件："
            dir "%BUILD_DIR%\*.pak" /b 2>nul || echo "未找到PAK文件"
            echo BUILD_SUCCESS=false>>%GITHUB_ENV%
            echo "[ERROR] 设置BUILD_SUCCESS=false"
            exit 1
          )
        ) else (
          echo "[ERROR] 构建验证失败 - 未找到可执行文件"
          echo "--- 详细诊断 ---"
          echo "构建目录完整结构:"
          if exist "build" (
            dir build /s /b | findstr /i "\.exe$" || echo "未找到任何exe文件"
            echo "--- bin目录内容 ---"
            if exist "build\bin" (
              dir "build\bin" /s /b
            ) else (
              echo "build\bin目录不存在"
            )
          ) else (
            echo "build目录不存在！"
          )
          echo BUILD_SUCCESS=false>>%GITHUB_ENV%
          echo "[ERROR] 设置BUILD_SUCCESS=false"
          exit 1
        )

    - name: Package Windows Build
      if: env.BUILD_SUCCESS == 'true'
      shell: powershell
      run: |
        Write-Host "=== Windows Build Packaging Stage ==="
        Write-Host "BUILD_SUCCESS: $env:BUILD_SUCCESS"
        
        if ($env:BUILD_SUCCESS -ne 'true') {
          Write-Host "Build not successful, skipping packaging"
          exit 1
        }
        
        # Diagnose build output directory structure
        Write-Host "=== Build Output Diagnostics ==="
        Write-Host "Checking build directory structure..."
        
        if (Test-Path "build") {
          Write-Host "build directory exists"
          Write-Host "build directory contents:"
          Get-ChildItem "build" -Force | Select-Object Name, PSIsContainer | Format-Table -AutoSize
          
          Write-Host "Finding all executable files:"
          $exeFiles = Get-ChildItem "build" -Recurse -Include "*.exe" -ErrorAction SilentlyContinue
          if ($exeFiles) {
            $exeFiles | ForEach-Object { 
              Write-Host "  Found: $($_.FullName) (size: $($_.Length) bytes)"
            }
          } else {
            Write-Host "No .exe files found"
          }
          
          Write-Host "Checking common build output paths:"
          $checkPaths = @(
            "build\bin\Release",
            "build\Release",
            "build\src\Release"
          )
          
          foreach ($path in $checkPaths) {
            if (Test-Path $path) {
              Write-Host "Path exists: $path"
              Get-ChildItem $path -ErrorAction SilentlyContinue | Select-Object Name, Length | Format-Table -AutoSize
            } else {
              Write-Host "Path does not exist: $path"
            }
          }
        } else {
          Write-Host "build directory does not exist!"
          Write-Host "Current directory contents:"
          Get-ChildItem . | Select-Object Name, PSIsContainer | Format-Table -AutoSize
        }
        
        Write-Host "=== Diagnostics Complete ==="
        Write-Host ""
        
        # Create packaging directory structure
        $artifactPath = "artifacts\windows-${{ matrix.arch }}"
        Write-Host "Creating package directory: $artifactPath"
        New-Item -ItemType Directory -Force -Path $artifactPath
        
        # Smart copy of core executable files and dependencies
        Write-Host "=== Starting main program file copy ==="
        
        # Define possible source paths (ordered by priority)
        $possiblePaths = @(
          "build\bin\Release",
          "build\Release",
          "build\src\Release"
        )
        
        $sourceFound = $false
        foreach ($sourcePath in $possiblePaths) {
          if (Test-Path $sourcePath) {
            Write-Host "Found build output directory: $sourcePath"
            
            # Check if it contains exe files
            $exeCount = (Get-ChildItem $sourcePath -Include "*.exe" -ErrorAction SilentlyContinue).Count
            if ($exeCount -gt 0) {
              Write-Host "Found $exeCount executable files, starting copy..."
              try {
                Copy-Item "$sourcePath\*" "$artifactPath\" -Recurse -Force
                Write-Host "Main program files copied successfully"
                $sourceFound = $true
                break
              } catch {
                Write-Host "Copy failed: $($_.Exception.Message)"
                continue
              }
            } else {
              Write-Host "Directory exists but no exe files: $sourcePath"
            }
          }
        }
        
        if (-not $sourceFound) {
          Write-Host "No valid build output found!"
          Write-Host "Attempting global search for exe files..."
          $allExes = Get-ChildItem "build" -Recurse -Include "*.exe" -ErrorAction SilentlyContinue
          if ($allExes) {
            Write-Host "Found exe files:"
            $allExes | ForEach-Object { Write-Host "  - $($_.FullName)" }
            
            # Copy the first found exe file and its directory
            $firstExe = $allExes[0]
            $sourceDir = $firstExe.Directory.FullName
            Write-Host "Using directory: $sourceDir"
            Copy-Item "$sourceDir\*" "$artifactPath\" -Recurse -Force -ErrorAction Continue
            Write-Host "Copied found files"
          } else {
            Write-Host "Critical error: No exe files found at all!"
            exit 1
          }
        }
        
        # Copy project documentation
        Write-Host "Copying project documentation..."
        Copy-Item "README.md" "$artifactPath\"
        Copy-Item "todo.md" "$artifactPath\"
        
        # Copy installer resource files
        Write-Host "Copying resource files..."
        if (Test-Path "resources") {
          New-Item -ItemType Directory -Force -Path "$artifactPath\resources"
          Copy-Item "resources\*" "$artifactPath\resources\" -Recurse -Force
          Write-Host "Resource files copied successfully"
        } else {
          Write-Host "resources directory does not exist, skipping resource copy"
        }
        
        # Skip BUILD_INFO.txt generation to avoid PowerShell parsing issues, focus on core build functionality
        Write-Host "Build packaging complete, skipping BUILD_INFO.txt generation"

    - name: Create Windows Installer
      shell: cmd
      run: |
        setlocal enabledelayedexpansion
        echo "=== 安装NSIS ==="
        choco install nsis -y
        
        echo "=== 生成${{ matrix.arch }}位CEF安装包 ==="
        mkdir Output 2>nul
        
        echo "检查NSIS脚本..."
        if not exist installer.nsi (
          echo ERROR: installer.nsi文件不存在
          exit /b 1
        )
        
        echo "检查构建产物..."
        if exist "build\bin\${{ env.BUILD_TYPE }}\DesktopTerminal-CEF.exe" (
          echo "[OK] 找到主程序文件"
          dir "build\bin\${{ env.BUILD_TYPE }}"
        ) else (
          echo "[ERROR] 未找到主程序文件"
          echo "构建目录内容："
          dir build /s
          exit /b 1
        )
        
        REM 提取CEF主版本号
        set "cef_version_full=${{ matrix.cef_version }}"
        for /f "tokens=1 delims=." %%a in ("!cef_version_full!") do set "cef_major=%%a"
        
        echo "生成CEF ${{ matrix.arch }}位安装包 (CEF !cef_major!)..."
        makensis -DARCH=${{ matrix.arch }} -DCEF_VERSION=!cef_major! installer.nsi
        if %errorlevel% neq 0 (
          echo 生成${{ matrix.arch }}位安装包失败
          exit /b 1
        )
        
        echo "生成的安装包："
        dir Output\*.exe
        
        REM 重命名安装包包含完整版本信息
        for %%f in (Output\*.exe) do (
          if "${{ matrix.arch }}"=="x86" (
            set "new_name=DesktopTerminal-CEF-v1.0.0-${{ matrix.arch }}-cef!cef_major!-win7-setup.exe"
          ) else (
            set "new_name=DesktopTerminal-CEF-v1.0.0-${{ matrix.arch }}-cef!cef_major!-setup.exe"
          )
          ren "%%f" "!new_name!"
          echo 重命名: %%f -^> !new_name!
        )

    - name: Upload Windows ${{ matrix.arch }} Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: DesktopTerminal-CEF-windows-${{ matrix.arch }}
        path: artifacts/windows-${{ matrix.arch }}/
        retention-days: 30

    - name: Upload Windows Installer
      uses: actions/upload-artifact@v4
      with:
        name: DesktopTerminal-CEF-installer-${{ matrix.arch }}
        path: Output/*.exe
        retention-days: 90

  # Linux构建 - 暂时屏蔽，专注Windows平台修复
  build-linux:
    if: false  # 屏蔽Linux构建
    runs-on: ubuntu-latest
    name: Linux 64-bit
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          ninja-build \
          pkg-config \
          libx11-dev \
          libxss1 \
          libnss3-dev \
          libatk-bridge2.0-dev \
          libdrm2 \
          libxcomposite-dev \
          libxdamage1 \
          libxrandr2 \
          libgbm1 \
          libxkbcommon-dev \
          libasound2-dev \
          libxtst6 \
          libxcomposite1 \
          libxcursor1 \
          libxi6

    - name: Install Qt ${{ env.QT_VERSION }}
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        cache: true

    - name: Cache CEF Linux
      id: cache-cef-linux
      uses: actions/cache@v3
      with:
        path: third_party/cef
        key: cef-linux-x64-75.1.14-verified-v3
        restore-keys: |
          cef-linux-x64-75.1.14-verified-

    - name: Verify CEF Cache Integrity (Linux)
      id: verify-cef-cache-linux
      run: |
        echo "验证Linux CEF缓存完整性..."
        CEF_VALID=false
        CEF_VERSION="75.1.14+gc81164e+chromium-75.0.3770.100"
        CEF_PLATFORM="linux64"
        CEF_BINARY_NAME="cef_binary_${CEF_VERSION}_${CEF_PLATFORM}"
        
        # 支持多种可能的CEF目录结构
        CEF_CHECK_PATHS=(
          "third_party/cef/${CEF_BINARY_NAME}/include/cef_version.h"
          "third_party/cef/include/cef_version.h"
          "third_party/cef/${CEF_BINARY_NAME}/cef_version.h"
        )
        
        echo "检查CEF头文件的多个可能路径..."
        
        for CHECK_PATH in "${CEF_CHECK_PATHS[@]}"; do
          echo "检查路径: $CHECK_PATH"
          if [[ -f "$CHECK_PATH" ]]; then
            echo "[OK] CEF头文件验证成功: $CHECK_PATH"
            CEF_VALID=true
            break
          fi
        done
        
        if [[ "$CEF_VALID" == "false" ]]; then
          echo "[ERROR] CEF头文件在所有预期路径中都不存在，需要重新下载"
          if [[ -d "third_party/cef" ]]; then
            echo "显示当前CEF目录结构用于诊断:"
            find third_party/cef -name "cef_version.h" -type f 2>/dev/null || echo "未找到任何cef_version.h文件"
            echo "删除不完整的CEF缓存..."
            rm -rf third_party/cef
          fi
        fi
        
        echo "cef-valid=$CEF_VALID" >> $GITHUB_OUTPUT

    - name: Download CEF (Linux)
      if: steps.cache-cef-linux.outputs.cache-hit != 'true' || steps.verify-cef-cache-linux.outputs.cef-valid != 'true'
      run: |
        echo "下载CEF for Linux x64..."
        chmod +x scripts/download-cef.sh
        scripts/download-cef.sh --platform=linux64 --force

    - name: Configure CMake
      run: |
        mkdir build
        cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -G Ninja \
          -DCMAKE_INSTALL_PREFIX=/usr/local

    - name: Build Project
      run: |
        cd build
        ninja -j$(nproc)

    - name: Verify Build
      run: |
        if [ -f "build/bin/DesktopTerminal-CEF" ]; then
          echo "[OK] Main executable found"
          ls -la build/bin/
          file build/bin/DesktopTerminal-CEF
        else
          echo "[ERROR] Main executable not found"
          find build -name "*DesktopTerminal*" -type f
          exit 1
        fi

    - name: Package Linux Build
      run: |
        mkdir -p artifacts/linux-x64
        cp -r build/bin/* artifacts/linux-x64/
        cp README.md todo.md artifacts/linux-x64/
        
        # Create build info
        cat > artifacts/linux-x64/BUILD_INFO.txt << 'EOF'
        DesktopTerminal-CEF Build Information
        ====================================
        Architecture: x64
        Platform: Linux 64-bit
        CEF Version: 75.1.14+gc81164e+chromium-75.0.3770.100
        Qt Version: ${{ env.QT_VERSION }}
        Build Type: ${{ env.BUILD_TYPE }}
        Build Date: $(date -u)
        Commit: ${{ github.sha }}
        EOF

    - name: Upload Linux Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: DesktopTerminal-CEF-linux-x64
        path: artifacts/linux-x64/
        retention-days: 30

  # macOS构建 - 暂时屏蔽，专注Windows平台修复
  build-macos-disabled:
    if: false  # 屏蔽macOS构建
    runs-on: macos-12
    name: macOS 64-bit (Disabled)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Qt ${{ env.QT_VERSION }}
      uses: jurplel/install-qt-action@v3
      with:
        version: ${{ env.QT_VERSION }}
        cache: true

    - name: Cache CEF macOS
      id: cache-cef-macos
      uses: actions/cache@v3
      with:
        path: third_party/cef
        key: cef-macos-x64-75.1.14
        restore-keys: |
          cef-macos-x64-

    - name: Download CEF
      if: steps.cache-cef-macos.outputs.cache-hit != 'true'
      run: |
        chmod +x scripts/download-cef.sh
        scripts/download-cef.sh --platform=macosx64

    - name: Configure CMake
      run: |
        mkdir build
        cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_OSX_DEPLOYMENT_TARGET=10.12

    - name: Build Project
      run: |
        cd build
        make -j$(sysctl -n hw.ncpu)

    - name: Verify Build
      run: |
        if [ -f "build/bin/DesktopTerminal-CEF" ]; then
          echo "[OK] Main executable found"
          ls -la build/bin/
          file build/bin/DesktopTerminal-CEF
        else
          echo "[ERROR] Main executable not found"
          find build -name "*DesktopTerminal*" -type f
          exit 1
        fi

    - name: Package macOS Build
      run: |
        mkdir -p artifacts/macos-x64
        cp -r build/bin/* artifacts/macos-x64/
        cp README.md todo.md artifacts/macos-x64/
        
        # Create build info
        cat > artifacts/macos-x64/BUILD_INFO.txt << 'EOF'
        DesktopTerminal-CEF Build Information
        ====================================
        Architecture: x64
        Platform: macOS 64-bit
        CEF Version: 75.1.14+gc81164e+chromium-75.0.3770.100
        Qt Version: ${{ env.QT_VERSION }}
        Build Type: ${{ env.BUILD_TYPE }}
        Build Date: $(date -u)
        Commit: ${{ github.sha }}
        EOF

    - name: Upload macOS Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: DesktopTerminal-CEF-macos-x64
        path: artifacts/macos-x64/
        retention-days: 30

  # 代码质量和安全检查
  code-quality:
    runs-on: ubuntu-latest
    name: Code Quality & Security
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify Project Structure
      run: |
        echo "[INFO] Checking project structure..."
        
        required_files=(
          "CMakeLists.txt"
          "README.md"
          "src/main.cpp"
          "scripts/build.sh"
          "scripts/build.bat"
          "scripts/download-cef.sh"
          "scripts/download-cef.bat"
        )
        
        for file in "${required_files[@]}"; do
          if [ -f "$file" ]; then
            echo "[OK] $file found"
          else
            echo "[ERROR] $file missing"
            exit 1
          fi
        done
        
        required_dirs=(
          "src/core"
          "src/cef"
          "src/config"
          "src/logging"
          "src/security"
          "cmake"
          "third_party/QHotkey"
        )
        
        for dir in "${required_dirs[@]}"; do
          if [ -d "$dir" ]; then
            echo "[OK] $dir/ found"
          else
            echo "[ERROR] $dir/ missing"
            exit 1
          fi
        done

    - name: Check Build Scripts
      run: |
        echo "[INFO] Verifying build scripts..."
        
        # Check if scripts are executable
        if [ -x "scripts/build.sh" ]; then
          echo "[OK] build.sh is executable"
        else
          echo "[ERROR] build.sh is not executable"
          chmod +x scripts/build.sh
        fi
        
        if [ -x "scripts/download-cef.sh" ]; then
          echo "[OK] download-cef.sh is executable"
        else
          echo "[ERROR] download-cef.sh is not executable"  
          chmod +x scripts/download-cef.sh
        fi

    - name: Install Qt for CMake test
      uses: jurplel/install-qt-action@v3
      with:
        version: '5.15.2'
        cache: true

    - name: Download CEF for CMake test
      run: |
        echo "[DOWNLOAD] Downloading CEF for CMake configuration test..."
        chmod +x scripts/download-cef.sh
        scripts/download-cef.sh --platform=linux64

    - name: Validate CMake Configuration
      run: |
        echo "[INFO] Checking CMake configuration..."
        cmake -S . -B build-test -DCMAKE_BUILD_TYPE=Debug || {
          echo "[ERROR] CMake configuration failed"
          exit 1
        }
        echo "[OK] CMake configuration successful"

    - name: Security Scan with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'table'
        severity: 'HIGH,CRITICAL'

  # 创建发布包（仅在发布时触发）
  create-release:
    needs: [build-windows, code-quality]  # 暂时只依赖Windows构建
    runs-on: ubuntu-latest
    name: Create Release Packages
    if: github.event_name == 'release'
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: DesktopTerminal-CEF-*
        merge-multiple: true

    - name: Create release packages
      run: |
        echo "[PACKAGE] Creating release packages..."
        
        # Windows 32-bit package
        cd DesktopTerminal-CEF-windows-x86
        zip -r ../DesktopTerminal-CEF-v${{ github.ref_name }}-windows-x86.zip .
        cd ..
        
        # Windows 64-bit package  
        cd DesktopTerminal-CEF-windows-x64
        zip -r ../DesktopTerminal-CEF-v${{ github.ref_name }}-windows-x64.zip .
        cd ..
        
        # macOS package
        cd DesktopTerminal-CEF-macos-x64
        tar -czf ../DesktopTerminal-CEF-v${{ github.ref_name }}-macos-x64.tar.gz .
        cd ..
        
        # Linux package
        cd DesktopTerminal-CEF-linux-x64
        tar -czf ../DesktopTerminal-CEF-v${{ github.ref_name }}-linux-x64.tar.gz .
        cd ..
        
        # Show created packages
        ls -la *.zip *.tar.gz

    - name: Upload release assets
      uses: softprops/action-gh-release@v1
      with:
        files: |
          DesktopTerminal-CEF-v${{ github.ref_name }}-windows-x86.zip
          DesktopTerminal-CEF-v${{ github.ref_name }}-windows-x64.zip
          DesktopTerminal-CEF-v${{ github.ref_name }}-macos-x64.tar.gz
          DesktopTerminal-CEF-v${{ github.ref_name }}-linux-x64.tar.gz
        body: |
          ## DesktopTerminal-CEF Release ${{ github.ref_name }}
          
          ### [PACKAGE] 包含的平台
          - **Windows 32-bit**: 支持Windows 7 SP1及以上系统 (CEF 75 - 最大兼容性)
          - **Windows 64-bit**: 支持Windows 7 SP1及以上系统 (CEF 75 - 最大兼容性)  
          - **macOS 64-bit**: 支持macOS 10.12及以上系统 (CEF 75 - 最大兼容性)
          - **Linux 64-bit**: 支持Ubuntu 16.04及以上系统 (CEF 75 - 最大兼容性)
          
          ### [CHECK] 主要特性
          - Qt5 + CEF集成的安全桌面终端
          - 完整的安全控制功能（键盘拦截、URL过滤、全屏锁定）
          - 跨平台兼容性
          - 针对Windows 7 SP1 32位系统的特别优化
          
          ### [REPORT] 系统要求
          - **Windows**: Windows 7 SP1 或更高版本
          - **macOS**: macOS 10.12 或更高版本  
          - **Linux**: Ubuntu 18.04 或等效发行版
          
          ### [LAUNCH] 快速开始
          1. 下载对应平台的包
          2. 解压到目标目录
          3. 运行主程序即可开始使用